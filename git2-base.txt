通常有2种获取Git项目仓库的方式：
1. $ git init
2. $ git clone

$ git clone https://github.com/libgit2/libgit2 mylibgit

请记住，工作目录下的每一个文件都不外乎两种状态：已跟踪/未跟踪。
已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在
工作一段时间后，它们的状态可能是未修改，已修改或已放入暂存区。
简而言之，已跟踪的文件就是Git已经知道的文件。

可以用`$ git status`查看哪些文件处于什么状态。
新建一个文件：
```bash
$ echo "MyProject" >> README
$ git status
On branch main
Your branch is up to date with 'origin/main'

Untracked files:
    (use "git add <file>..." to include in what will be committed)
	    README

nothing added to commit but untracked files present (use "git add" to track)
```


跟踪新文件
使用`git add`开始跟踪一个文件。
```bash
$ git add README
$ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   README

```
只要在`Changes to be committed`这行下面的，就说明是已暂存状态。如果此时提交，
那么该文件在你运行`git add`时的版本将被留存在后续的历史记录中。
`git add`命令如果参数时路径，则将递归地跟踪该目录下的所有文件。



$ git diff 比较的是工作目录中当前文件和暂存区域快照之间的差异。
若要查看已暂存的将要添加到下次提交里的内容，使用`$ git diff --staged`，这条命令
将比对已暂存文件与最后一次提交的文件的差异。

```bash
$ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README


```


提交更新
在提交之前，务必确认还有什么已修改或新建的文件还没有`git add`过，否则提交的时候
不会记录这些尚未暂存的变化。这些已修改但未暂存的文件只会保留在本地磁盘。
$ git commit
更详细的内容修改提示可以用`-v`选项查看，会显示diff信息。
每一次运行提交操作，都是对项目做一次快照。


移除文件
要从Git中移除某个文件，就必须要从已跟踪文件清单中移除(确切地说是从暂存区域)，
然后提交。可以用`git rm`命令完成此项工作，并连带从工作目录中删除指定的文件，
这样以后就不会出现在未跟踪文件清单中了。

如果要删除之前修改过或已经放到暂存区的文件，则必须使用`-f`。

另外一种情况是，我们想把文件从Git仓库中删除(即从暂存区删除)，但仍希望保留在
当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让Git继续跟踪。
当你忘记添加.gitignore，不小心把一个很大的日志文件或一堆.a这样的文件添加到
暂存区时，这一做法尤其有用。为达到这一目的，使用`--cached`选项:
$ git rm --cached README
$ git rm log/\*.log  # 删除log/目录下扩展名为.log的所有文件。
$ git rm \*~   # 删除所有以~结尾的文件
注意星号的转义。git有自己的匹配方式。


移动文件
$ git mv file_from file_to
其实，`git mv`相当于运行了下面三条命令：
$ mv README.md README.md
$ git rm README.md
$ git add README


查看提交历史
git log 常用选项
-p: 显示每次提交所引入的差异。`-2`只显示最近的两次提交。
--stat: 查看每次提交的简略统计信息

$ git log --pretty=oneline / short / full / fuller / format
$ git log --pretty=format:"%h - %an, %ar : %s"
format常用格式说明
%H/%h 完整哈希/简写哈希
%T/%t 树的完整哈希/简写哈希
%P/%p 父提交的完整/简写哈希
%an/%ae   作者名字/邮件
%ad/%ar   作者修订日期 普通日期/距今多久
%cn/%ce   提交者名字/邮件
%cd/%cr   提交日期     普通日期/距今多久
%s    提交说明

--pretty 加 --graph 美化格式

git log 常用选项
-p     见上文
--stat 见上文
--shortstat  只显示--stat中最后的行数修改添加移除统计
--name-only  仅显示已修改的文件清单
--name-status 显示新增，修改，删除的文件清单
--abbrev-commit 仅显示SHA-1校验和所有40个字符的前几个字符
--relative-date 相对时间
--graph  以ascii图形显示分支与合并历史
--pretty 使用其他格式
--no-merges 不显示合并提交


撤销操作
1. --amend
提交完了发现漏掉了几个文件或写错了提交信息。此时可以
$ git commit --amend
来重新提交。
这个命令会将暂存区的文件提交
如果自上次以来还未做任何修改，那么快照会不变，修改的只是提交信息。

从效果上来说，就像是旧提交从未存在过一样。


取消暂存的文件
比如，本来想要将两个文件作为两次独立的修改提交，但不小心
`git add *`了，如何只取消暂存两个中的一个呢？
```bash
$ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   CONTRIBUTE.md
        new file:   README


czy@DESKTOP-NC9KL6B MINGW64 /d/tmp/libgit2 (main)
$ git restore --staged README

czy@DESKTOP-NC9KL6B MINGW64 /d/tmp/libgit2 (main)
$ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   CONTRIBUTE.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        README
```


远程仓库
远程仓库是指托管在因特网或其他网络中的你的版本库
查看已经配置的远程仓库服务器，运行`git remote`，它会列出你指定的
每一个远程服务器的简写。
`-v`列出详细信息


添加远程仓库
$ git remote add pb https://github.com/paulboone/ticgit
添加一个新远程仓库，同时指定简写
现在可以使用简写pb来代替整个url

从远程仓库pull与fetch
从远程仓库获取数据，可以执行：
$ git fetch <remote>
这个命令会访问远程仓库，从中拉取所有你还没有的数据。
执行完成后，你将会拥有那个远程仓库中所有分支的引用，
可以随时合并或查看。

使用clone命令克隆的仓库，命令会自动将其添加为远程仓库并且以"origin"
为默认简写。
必须注意`get fetch`只会将数据下载到你的本地仓库，并不会自动合并
或修改你当前的工作。只能手动合并。

如果你的当前分支设置了跟踪远程分支，那么可以用`git pull`来自动抓取后
合并该远程分支到当前分支。
这，或许，是个更简单舒服的工作流程。

推送到远程仓库
当你想分享你的项目，必须将其推送到上游。
$ git push <remote> <branch>

查看某个远程仓库
$ git remote show <remote>

远程仓库的重命名与移除
$ git remote rename pb paul
$ git remote
origin
paul

$ git remote remove paul
git remote
origin


标签
列出标签
$ git tag
$ git tag -l "v1.8.5*"

创建标签
Git支持两种标签，lightweight, annotated。(轻量标签/附注标签)
轻量标签很像一个不会改变的分支 ---- 它只是某个提交的引用。
附注标签是存储在Git数据库中的一个完整对象，可被校验，其中包含
打标签者的名字，电子邮件地址，日期时间，标签信息，并可使用GPG
(GNU Privacy Guard)签名并验证。

附注标签
打标签 -a
$ git tag -a v1.4 -m "version 1.4,OH YEAH"
查看标签信息
$ git show v1.4

轻量标签
打标签 不使用选项，只提供名字
$ git tag v1.4-lw

对过去的提交打标签
$ git tag -a v1.2 9fceb02

共享标签
默认情况下，`git push`并不会上传标签，必须显式推送
$ git push origin v1.5
推送全部标签
$ git push origin --tags  # 并不区分轻量标签和附注标签

删除标签
$ git tag -d v1.4-lw
更新远程标签的两种方式：
$ git push origin :refs/tags/v1.4-lw
$ git push origin --delete v1.4-lw

checkout标签
如果你想查看某个标签所指向的文件版本，可以使用`git checkout`。
虽然这会使你的仓库处于 "detached HEAD"状态。
在"detached HEAD"状态下，如果你做了某些更改然后提交，标签不会变化，
但你的新提交将不属于任何分支，并且将无法访问，除了通过哈希。
因此，如果你需要进行更改，比如修复旧版本中的错误，那么通常需要创建
一个新分支：
$ git chekcout -b version2 v2.0.0


























































































































